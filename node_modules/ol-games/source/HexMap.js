/*	Copyright (c) 2017 Jean-Marc VIGLINO,
  released under the CeCILL-B license (French BSD license)
  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).

  @classdesc
  ol_source_HexMap is a source for drawing hex map.

  Inherits from:
  <ol_source_ImageCanvas>
*/
import ol_source_ImageCanvas from 'ol/source/ImageCanvas'



/** A source for exagonal map
 * @constructor ol_source_HexMap
 * @extends {ol.source.ImageCanvas}
 * @param {Object} options
 *  @param {ol/HexGrid} options.grid
 * @todo
 */

var ol_source_HexMap = class olsourceHexMap extends ol_source_ImageCanvas {
	constructor(options) {
		options = options || {};

		super({
			canvasFunction: function(extent, res, ratio, size) {
				return this.drawHex(extent, res, ratio, size);
			}
		});
		this.canvas = document.createElement('canvas');
		this.context = this.canvas.getContext('2d');
		this.grid = options.hexGrid;
		this.grid.on('change', this.changed.bind(this));

	}
	/** draw an hexagon
	 * @param {Canvas context2D} ctx
	 * @param {ol.pixel}
	 * @param {Number} size (in pixel)
	 * @param {bool} fill to fill the polygon
	 * @param {Number} min, default 0
	 * @param {Number} max, default 6
	 * @param {Number} dl offset, default 0
	 */
	drawHexagon(ctx, p, size, fill, min, max, dl, image) {
		var p0;
		ctx.beginPath();
		min = min || 0;
		max = max || 6;
		dl = dl || 0;
		for (var i = min; i <= max; i++) {
			p0 = this.grid.hex_corner(p, size - dl, i);
			if (i != min) {
				ctx.lineTo(p0[0], p0[1]);
			} else {
				ctx.moveTo(p0[0], p0[1]);
			}
		}
		ctx.stroke();
		if (fill) {
			ctx.fill();
			if (image) {
				ctx.drawImage(image, p[0] - size / 2, p[1] - size / 2, size, size);
			}
		}
	}
	/** Display coordinates on hexagon
	 * @param { false | axial | offset | cube } what coord type
	 */
	showCoordiantes(what) {
		this.coordinates_ = what;
		this.changed();
	}
	/** Draw the hex map
	 * @param {ol.extent} extent map extent
	 * @param {number} res current resolution
	 * @param {number} ratio current ratio
	 * @param {ol.size} size map size (px)
	 * @param {ol.proj.Projection} current projection
	 * @API stable
	 */
	drawHex(extent, res, ratio, size /*, proj*/ ) {
		var w = this.canvas.width = size[0];
		var h = this.canvas.height = size[1];
		this.res = res
		this.ratio = ratio
		this.extent = extent;
		let roadArray = []
		// Hexagon radius in pixel
		var ctx, x, y, p, c;
		var pxSize = this.grid.getSize() / res;
		this.pxSize = pxSize
		if (pxSize < 8) {
			var pattern = document.createElement('canvas');
			// $("#pattern").html(pattern)
			ctx = pattern.getContext('2d');
			// pattern size
			var psize = 10;
			var dw = 2 * Math.sqrt(3) * pxSize * ratio * psize;
			var dh = 3 * pxSize * ratio * psize;
			pattern.width = Math.round(dw);
			pattern.height = Math.round(dh);
			console.log(pattern.width, pattern.height)
			ctx.scale(ratio, ratio);
			ctx.lineWidth = 1.5;

			ctx.fillStyle = "transparent";
			var h0 = this.grid.coord2hex([extent[0], extent[3]]);

			let hexes = []
			for (x = -psize; x < 2 * psize + 2; x++) {
				for (y = -3; y < 2 * psize + 2; y++) {
					hexes.push([h0[0] + x, h0[1] + y]);
					p = this.grid.hex2coord([h0[0] + x, h0[1] + y]);
					p[0] = (p[0] - extent[0]) / res;
					p[1] = pattern.height - (p[1] - extent[3]) / res;
					// Draw
					ctx.strokeStyle = "rgba(0,0,0,0.5)";
					this.drawHexagon(ctx, p, pxSize, 0, 3);
					ctx.strokeStyle = "rgba(255,255,255,0.8)";
					this.drawHexagon(ctx, p, pxSize, false, 2, 5, 2);
					ctx.strokeStyle = "rgba(0,0,0,0.3)";
					this.drawHexagon(ctx, p, pxSize, false, 5, 8, 2);
				}
			}

			this.grid.setHexes(hexes);
			// Prevent coord rounding
			var cache = document.createElement('canvas');
			ctx = cache.getContext('2d');
			cache.width = Math.round(w + (dw - pattern.width) * Math.floor(w / pattern.width));
			cache.height = Math.round(h + (dh - pattern.height) * Math.floor(h / pattern.height));
			ctx.fillStyle = ctx.createPattern(pattern, "repeat");
			ctx.fillRect(0, 0, cache.width, cache.height);
			this.context.drawImage(cache, 0, 0, w, h, 0, 0, cache.width, cache.height);
		} else {
			ctx = this.context;
			ctx.save();
			var o0 = this.grid.hex2offset(this.grid.coord2hex([extent[0], extent[1]]));
			var o1 = this.grid.hex2offset(this.grid.coord2hex([extent[2], extent[3]]));
			var row = this.grid.getRow();
			var col = this.grid.getCol();
			ctx.scale(ratio, ratio);
			ctx.lineWidth = 1.5;
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			// fontSize with scale
			ctx.font = pxSize / 3 + "px Arial";

			// col row
			var col1 = -Math.floor(col / 2),
				col2 = col1 + col
			var row1 = -Math.floor(row / 2),
				row2 = row1 + row


			if (o0[0] < col1) {
				o0[0] = col1
			}
			if (o0[1] < row1) {
				o0[1] = row1
			}
			if (o1[0] > col2) {
				o1[0] = col2
			}
			if (o1[1] > row2) {
				o1[1] = row2
			}
			let hexes = []
			// draw
			for (x = o0[0]; x < o1[0]; x++) {
				for (y = o0[1]; y < o1[1]; y++) {
					if (y % 2 == 0 && x == col1) {
						continue
					}
					let image = undefined
					var hex = this.grid.offset2hex([x, y], this.layout_);
					hexes.push(hex);
					p = this.grid.hex2coord(hex);
					// Coord to pixel
					p[0] = (p[0] - extent[0]) / res;
					p[1] = h / ratio - (p[1] - extent[1]) / res;
					// Draw
					c = this.grid.hex2offset(hex);
					let item = this.grid.coordinateMap[c[0] + "," + c[1]];
					if (item) {
						if (item.terrainColor && item.terrainColor.length > 1) {
							ctx.fillStyle = item.terrainColor;
						} else {
							ctx.fillStyle = item.elevationColor;
						}
						if (item.terrainCover && item.terrainCover.length > 0) {
							image = this.grid.imageMap.values_[item.terrainCover]
						}
						if (item.bridgeFlag == '1') {
							image = this.grid.imageMap.values_["bridge"]
						}
						if (item.roadVoList && item.roadVoList.length > 0) {
							for (let roadItem of item.roadVoList) {
								// roadItem.fromOffset = item.offset
								// roadItem.fromCoordinate = item.coordinate
								// roadItem.roadColor = item.roadColor
								// roadItem.roadName = item.roadName
								// roadItem.roadWidth = item.roadWidth
								roadArray.push(roadItem);
							}
						}

					} else {
						ctx.fillStyle = "#fff";
					}

					ctx.strokeStyle = "rgba(0,0,0,0.25)";
					this.drawHexagon(ctx, p, pxSize, true, null, null, null, image);
					// ctx.strokeStyle = "rgba(255, 85, 0, 0.8)";
					// this.drawHexagon(ctx, p, pxSize, false, 3, 4, 5);
					// ctx.strokeStyle = "rgba(0,0,0,0.3)";
					// this.drawHexagon(ctx, p, pxSize, false, 5, 8, 2);
					// Show coords
					if (pxSize > 20) {
						ctx.fillStyle = "#000";
						switch (this.coordinates_) {
							case 'axial': {
								ctx.fillText(hex[0] + "," + hex[1], p[0], p[1]);
								break;
							}
							case 'cube': {
								c = this.grid.hex2cube(hex);
								//c=["x","y","z"]
								for (var a = 0; a < 3; a++) {
									var angle_rad = -Math.PI / 180 * (a * 120 + 30);
									ctx.fillText(c[a], p[0] + Math.cos(angle_rad) * pxSize * 0.5, p[1] +
										Math
										.sin(angle_rad) * pxSize * 0.5);
								}
								break;
							}
							case 'offset': {

								if (!(c[1] % 2 == 0 && c[0] == -65)) {
									let str = this.hexToPointNumber(c[1], c[0], 99, 130)
									ctx.font = 15;
									ctx.fillText(str, p[0], p[1] - pxSize / 2);

									if (item.elevation) {
										ctx.fillText(item.elevation, p[0], p[1] + pxSize / 1.5);
										// ctx.fillText(c[0] + "," + c[1], p[0], p[1] + pxSize / 1.5);
									}
									// ctx.fillText(c[1] + "," + c[0], p[0], p[1] - 20);
								}
								// ctx.fillText(c[1] + "," + c[0], p[0], p[1]);
								break;
							}
							default:
								break;
						}
					}
					if (x == o1[0] - 1 && y == o1[1] - 1) {
						this.drawRoad(ctx, roadArray, res, h, ratio)
						if (this.chessImageArr) {
							this.drawChessImage(ctx, this.chessImageArr, res, h, ratio)
						}
						if (this.chessMoveArray) {
							this.drawArrow(this.chessMoveArray)
						}
					}
				}
			}
			ctx.restore();
		}
		return this.canvas;
	}
	drawRoad(ctx, roadArray, res, h, ratio) {
		for (let item of roadArray) {
			let fromOffset = item.fromOffset.split(",");
			let toOffset = item.toOffset.split(",");
			let hex1 = this.grid.offset2hex([fromOffset[0], fromOffset[1]], this.layout_);
			let p1 = this.grid.hex2coord(hex1);
			p1[0] = (p1[0] - this.extent[0]) / res;
			p1[1] = h / ratio - (p1[1] - this.extent[1]) / res;
			let hex2 = this.grid.offset2hex([toOffset[0], toOffset[1]], this.layout_);
			let p2 = this.grid.hex2coord(hex2);
			p2[0] = (p2[0] - this.extent[0]) / res;
			p2[1] = h / ratio - (p2[1] - this.extent[1]) / res;

			ctx.beginPath();
			ctx.strokeStyle = item.roadColor;
			ctx.lineWidth = item.roadWidth;
			ctx.moveTo(p1[0], p1[1]);
			ctx.lineTo(p2[0], p2[1]);
			ctx.stroke();
		}
	}
	moveChessImage(chessImageArr) {
		this.chessImageArr = chessImageArr;
		this.changed();
	}
	drawChessImage(ctx, chessImageArr, res, h, ratio) {
		// var h = this.canvas.height
		// let ctx = this.context;
		// ctx.scale(this.ratio, this.ratio);
		for (let item of chessImageArr) {
			let offset = item.offset;
			let offArray = offset.split(",")
			let hex = this.grid.offset2hex(offArray, this.layout_);
			let p = this.grid.hex2coord(hex);
			p[0] = (p[0] - this.extent[0]) / res;
			p[1] = h / ratio - (p[1] - this.extent[1]) / res;
			let image = this.grid.imageMap.values_[item.info.chessPiecesNumber]
			ctx.drawImage(image, p[0] - this.pxSize / 2, p[1] - this.pxSize / 2, this.pxSize, this
				.pxSize);
				if(item.info.status.length > 0){
					let status = item.info.status.split(",")
					let filteredArr = status.filter(function(item) {
					    // 检查项目是否有实际内容（忽略空字符串，0，false，null，undefined和NaN）
					    return item || item === 0 || item === false;
					});
						for (let i in filteredArr) {
								let image1 = this.grid.imageMap.values_[filteredArr[i]]
								ctx.drawImage(image1, p[0] + this.pxSize / 2, p[1] - this.pxSize / 2 + this.pxSize/4 * i, this.pxSize/4, this
									.pxSize/4);

						}
				}
			// 棋子已经行动过怎加灰色效果
			if(item.info.roundActionPoint=='0'){
				// console.log(this.grid.imageMap.values_['KILL'])
				// for (const [key, value] of this.grid.imageMap) {
				// 	console.log("acted")
				// 	console.log(key, value);
				// }
				let image1 = this.grid.imageMap.values_['ACTED']
				ctx.globalAlpha = 0.8;
				ctx.drawImage(image1, p[0] - this.pxSize / 2, p[1] - this.pxSize / 2, this.pxSize, this
					.pxSize);
				ctx.globalAlpha = 1;
			}


			// ctx.font = "4px";
			// ctx.fillText("正常",p[0] + this.pxSize /1.5, p[1] - this.pxSize / 2);
		}

	}
	chessMoveChange(chessMoveArray) {
		this.chessMoveArray = chessMoveArray;
		this.changed();
	}
	hexToPointNumber(row, col, allRow, allCol) {

		let rowNumber = 0;
		let rowNumberStr = "";
		rowNumber = 49 - row + 25;
		if (rowNumber < 10) {
			rowNumberStr = "00" + rowNumber
		} else if (rowNumber < 100) {
			rowNumberStr = "0" + rowNumber
		} else {
			rowNumberStr = rowNumber
		}
		let colNumber = 0;
		let colNumberStr = "";
		if (row % 2 == 0) {
			colNumber = col + 65;
		} else {
			colNumber = col + 66;
		}

		if (colNumber < 10) {
			colNumberStr = "00" + colNumber
		} else if (colNumber < 100) {
			colNumberStr = "0" + colNumber
		} else {
			colNumberStr = colNumber
		}
		// console.log('colNumberStr: ', rowNumberStr + colNumberStr);
		return rowNumberStr + "" + colNumberStr
	}
	drawArrow(array) {
		for (let i in array) {
			if (i > 0) {
				let fromOffset = array[i - 1].offset;
				let toOffset = array[i].offset;
				var h = this.canvas.height
				let hex1 = this.grid.offset2hex(fromOffset.split(","), this.layout_);
				let p1 = this.grid.hex2coord(hex1);
				p1[0] = (p1[0] - this.extent[0]) / this.res;
				p1[1] = h / this.ratio - (p1[1] - this.extent[1]) / this.res;
				let hex2 = this.grid.offset2hex(toOffset.split(","), this.layout_);
				let p2 = this.grid.hex2coord(hex2);
				p2[0] = (p2[0] - this.extent[0]) / this.res;
				p2[1] = h / this.ratio - (p2[1] - this.extent[1]) / this.res;
				let ctx = this.context;
				// 保存画笔状态
				ctx.save();
				// 设置箭头样式
				ctx.lineWidth = 2;
				ctx.strokeStyle = "#000000";
				ctx.fillStyle = "#FF0000";
				ctx.lineCap = "round";
				ctx.lineJoin = "round";
				ctx.shadowBlur = 2;
				ctx.shadowColor = "rgba(0, 0, 0, 0.5)";

				// 计算向量及其长度
				var dx = p2[0] - p1[0];
				var dy = p2[0] - p1[1];
				var distance = Math.sqrt(dx * dx + dy * dy);

				// 计算箭头头部的终点坐标
				var headX = p2[0] - dx / distance * 10;
				var headY = p2[1] - dy / distance * 10;

				// 绘制箭身
				ctx.beginPath();
				ctx.moveTo(p1[0], p1[1]);
				ctx.lineTo(headX, headY);
				ctx.stroke();

				// 绘制箭头头部
				ctx.beginPath();
				ctx.moveTo(p2[0], p2[1]);
				ctx.lineTo(headX - dy / distance * 5, headY + dx / distance * 5);
				ctx.lineTo(headX + dy / distance * 5, headY - dx / distance * 5);
				ctx.closePath();
				ctx.fill();

				// 恢复画笔状态
				ctx.restore();
			}
		}

	}
}

export default ol_source_HexMap
